<!DOCTYPE html>
<html>
<head>
  <title>idbnext benchmarking</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
</head>
<body>
  <h1>idbnext benchmarks</h1>
  <p>Benchmarking the difference between current the PouchDB indexeddb backend, "correct" raw indexeddb indexes, and a singular artificial index.</p>
  <p><strong style="color: red">!!!Open the console to see output!!!</strong></p>
  <h2>Generate me some data</h2>
  <div><label for="documents">How many documents? </label><input type="text" id="documents" value=1000></div>
  <button id="generate">Generate</button>
  <button id="clear-generate">Clear then generate</button>
  <h2>Generate me some indexes</h2>
  <div><button id="indexes-pouchdb">Pouchdb</button></div>
  <div><button id="indexes-native">Native</button></div>
  <div><button id="indexes-artificial">Artificial</button></div>
  <h2>Query me some indexes</h2>
  <div><button id="query-pouchdb">Pouchdb</button></div>
  <div><button id="query-native">Native</button></div>
  <div><button id="query-artificial">Artificial</button></div>
<script src="//cdn.jsdelivr.net/npm/pouchdb@6.3.4/dist/pouchdb.min.js"></script>
</script>
<script>
  /* jshint browser: true */
  var IndexedDB = window.indexedDB;

  var POUCHDB_NAME = 'idbnext';
  var IDB_NATIVE_NAME = 'idbnext-native';
  var IDB_ARTIFICIAL_NAME = 'idbnext-artificial';

  // DBs etc
  var db, iNative, iArtificial;
  var iNativeData = 'data';
  var iNativeViewCreatedDate = 'view__created_date';
  var iNativeViewTypeByPersonByDate = 'view__type_by_person_by_date';
  var iArtificialData = 'data';
  var iArtificialView = 'view';

  function bootstrap() {
    console.log('Initialising Databases...');
    db = new PouchDB(POUCHDB_NAME);
    return db.destroy()
    .then(function() {
      db = new PouchDB(POUCHDB_NAME);
      return db.put({
        _id: '_design/idbnext',
        views: {
          created_date: {
            map: 'function(doc) { emit(doc.created_date); }'
          },
          type_by_person_by_date: {
            map: 'function(doc) { emit([doc.type, doc.created_by, doc.created_date]); }'
          }
        }
      });
    }).then(function() {
      console.log('PouchDB initialised!');
      return new Promise(function(resolve, reject) {
        IndexedDB.deleteDatabase(IDB_NATIVE_NAME);
        IndexedDB.deleteDatabase(IDB_ARTIFICIAL_NAME);

        var native = IndexedDB.open(IDB_NATIVE_NAME, 1);
        var artificial = IndexedDB.open(IDB_ARTIFICIAL_NAME, 1);

        var nativeDone = false;
        var artificialDone = false;

        native.onerror = reject;
        artificial.onerror = reject;

        native.onsuccess = function(event) {
          console.log('Native-Index IDB initialised!');
          iNative = native.result;
          if (artificialDone) {
            resolve();
          }
        };
        artificial.onsuccess = function(event) {
          console.log('Artificial-Index IDB initialised!');
          iArtificial = artificial.result;
          if (nativeDone) {
            resolve();
          }
        };

        // TODO: work out the Chrome 30 version of this?
        native.onupgradeneeded = function(event) {
          var idb = event.target.result;
          idb.createObjectStore(iNativeData, { keyPath: '_id' });
          // I realise IRL these keyPaths would be not be named so nicely, and would be generated based on
          // what is emited from views.
          idb.createObjectStore(iNativeViewCreatedDate, { keyPath: 'created_date' });
          idb.createObjectStore(iNativeViewTypeByPersonByDate, { keyPath: ['type', 'created_by', 'created_date']});
        };

        artificial.onupgradeneeded = function(event) {
          var idb = event.target.result;
          idb.createObjectStore(iArtificialData, { keyPath: '_id' });

          // TODO: unsure if this is actually how this would work
          idb.createObjectStore(iArtificialView, { keyPath: 'keyArray'});
        };
      });
    });
  }

  bootstrap();

  // Nicked from: http://stackoverflow.com/questions/105034/ddg#2117523
  function uuidv4() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  function oneOf(things) {
    return things[Math.floor(Math.random() * things.length)];
  }

  function between(start, end) {
    return start + Math.random() * (end - start);
  }

  function generate() {
    var store = function(docs, total) {
      return db.bulkDocs(docs)
      .then(function() {
        // Native
        var tx = iNative.transaction(iNative.objectStoreNames, "readwrite"); // TODO: maybe old style readwrite?

        var data = tx.objectStore(iNativeData),
            viewCreatedDate = tx.objectStore(iNativeViewCreatedDate),
            viewTypeByPersonByDate = tx.objectStore(iNativeViewTypeByPersonByDate);

        docs.forEach(doc => {
          data.add(doc);
          // Yes, this would be running the actual JS instead of manually rewriting it
          viewCreatedDate.add({
            created_date: doc.created_date,
            _id: doc._id
          });
          viewTypeByPersonByDate.add({
            type: doc.type,
            created_by: doc.created_by,
            created_date: doc.created_date,
            _id: doc._id
          });
        });

        return new Promise(function(resolve, reject) {
          tx.oncomplete = resolve;
          tx.onerror = reject;
        });
      })
      .then(function() {
        // Artificial
        var tx = iArtificial.transaction(iArtificial.objectStoreNames, "readwrite"); // TODO: maybe old style readwrite?

        var data = tx.objectStore(iArtificialData),
            views = tx.objectStore(iArtificialView);

        docs.forEach(doc => {
          data.add(doc);
          // Yes, this would be running the actual JS instead of manually rewriting it
          views.add({
            keyArray: ['created_date', doc.created_date],
            _id: doc._id
          });
          views.add({
            // TODO: would keyArray[1] be an array or would it be exploded out?
            keyArray: ['type_by_person_by_date', [doc.type, doc.created_by, doc.created_date]],
            _id: doc._id
          });
        });

        return new Promise(function(resolve, reject) {
          tx.oncomplete = resolve;
          tx.onerror = reject;
        });
      })
      .then(function() {
        console.log('Generated', total);
      })
      .catch(function(err) {
        console.error('Failed to generate', total);
        console.error(err);
      });
    };

    var docsToGenerate = document.getElementById('documents').value;

    var BATCH_SIZE = 100;
    var docs = [];
    var total = 0;
    for (var i = 0; i < docsToGenerate; i++) {
      total += 1;
      docs.push({
        _id: uuidv4(),
        type: oneOf(['foo', 'bar', 'smang']),
        created_date: Math.floor(between(Date.parse('2000'), Date.parse('2017'))),
        created_by: 'person:' + Math.floor(between(0, 1000)),
        a_boolean: oneOf([true, false, null, undefined]),
      });

      if (docs.length === BATCH_SIZE) {
        store(docs, total);
        docs = [];
      }
    }
    store(docs, total)
      .then(function() {
        // TODO: pull info from idb as well?
        return db.info();
      })
      .then(function(info) {
        console.log('GENERATION COMPLETE');
        console.log('Total Docs:', info);
      })
      .catch(function(err) {
        console.error('Failed to info');
        console.error(err);
      });
  }

  function time(fnToTime) {
    var before = new Date().getTime();
    var result = fnToTime();
    if (result.then) {
      return result.then(function(result) {
        var t = new Date().getTime() - before;
        return [t, result];
      });
    } else {
      var t = new Date().getTime() - before;
      return [t, result];
    }
  }

  document.getElementById('clear-generate').addEventListener('click', function() {
    bootstrap().then(generate);
  });
  document.getElementById('generate').addEventListener('click', generate);
  document.getElementById('indexes-pouchdb').addEventListener('click', function() {
    console.log('Warming PouchDB indexes...');

    time(function() {return db.query('idbnext/created_date', {limit: 1});})
      .then(function(timed) {
        console.log('Warmed PouchDB indexes, took', timed[0], 'millis');
      });
  });
  document.getElementById('indexes-native').addEventListener('click', function() {

  });
  document.getElementById('indexes-artificial').addEventListener('click', function() {

  });
  document.getElementById('query-pouchdb').addEventListener('click', function() {
    console.log('Querying PouchDB indexes');

  });
  document.getElementById('query-native').addEventListener('click', function() {

  });
  document.getElementById('query-artificial').addEventListener('click', function() {

  });
</script>
</body>
</html>
