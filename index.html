<!DOCTYPE html>
<html>
<head>
  <title>idbnext benchmarking</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
</head>
<body>
  <h1>idbnext benchmarks</h1>
  <p>Benchmarking the difference between current the PouchDB indexeddb backend, "correct" raw indexeddb indexes, and a singular artificial index.</p>
  <p><strong style="color: red">!!!Open the console to see output!!!</strong></p>
  <h2>Main engine on</h2>
  <p>Click this first, or click it later to reset everything (NB: refresh first otherwise things break)</p>
  <button id='bootstrap'>Bootstrap</button>
  <h2>Generate me some data</h2>
  <div><label for="documents">How many documents? </label><input type="text" id="documents" value=1000></div>
  <button id="generate">Generate</button>
  <h2>Warm me some indexes</h2>
  <div>
    <button id="indexes-pouchdb">Pouchdb</button>
    <button id="indexes-native">Native</button>
    <button id="indexes-artificial">Artificial</button>
  </div>
  <h2>Query me some indexes</h2>
  <div>
    <button id="query-pouchdb">Pouchdb</button>
    <button id="query-native">Native</button>
    <button id="query-artificial">Artificial</button>
  </div>
  <h2>Look at me timings</h2>
  <div><button id="dump-timings">Dump Timings</button></div>
  <br/><br/>
  <div><button id="reset-timings">!!!Reset Timings!!!</button></div>
<script src="//cdn.jsdelivr.net/npm/pouchdb@6.3.4/dist/pouchdb.min.js"></script>
</script>
<script>
  /* jshint browser: true */

  // MOZ MOZ MOZ MOZ MOZ MOZ MOZ
  // MOZ MOZ MOZ MOZ MOZ MOZ MOZ
  //  The next bit is from MDN
  // MOZ MOZ MOZ MOZ MOZ MOZ MOZ
  // MOZ MOZ MOZ MOZ MOZ MOZ MOZ
  // In the following line, you should include the prefixes of implementations you want to test.
  window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
  // DON'T use "var indexedDB = ..." if you're not in a function.
  // Moreover, you may need references to some window.IDB* objects:
  window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction || {READ_WRITE: "readwrite"}; // This line should only be needed if it is needed to support the object's constants for older browsers
  window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;
  // (Mozilla has never prefixed these objects, so we don't need window.mozIDB*)

  var POUCHDB_NAME = 'idbnext';
  var IDB_NATIVE_NAME = 'idbnext-native';
  var IDB_ARTIFICIAL_NAME = 'idbnext-artificial';

  // DBs etc
  var db, iNative, iArtificial;
  var iNativeData = 'data';
  var iViewCreatedDate = 'view__created_date';
  var iViewTypeByPersonByDate = 'view__type_by_person_by_date';
  var iArtificialData = 'data';
  var iArtificialView = 'view';

  // Total time measurements
  function time(title, fn) {
    var before = new Date().getTime();
    var result = fn();
    if (result.then) {
      return result.then(function(result) {
        var t = new Date().getTime() - before;
        times[title] = (times[title] || 0) + t;
        return [t, result];
      });
    } else {
      var t = new Date().getTime() - before;
      times[title] = (times[title] || 0) + t;
      return [t, result];
    }
  }
  var times = {};

  function bootstrap() {
    console.log('Boostrapping databases...');
    times = {};
    db = new PouchDB(POUCHDB_NAME);
    return db.destroy()
    .then(function() {
      db = new PouchDB(POUCHDB_NAME);
      return db.put({
        _id: '_design/idbnext',
        views: {
          created_date: {
            map: 'function(doc) { emit(doc.created_date); }'
          },
          type_by_person_by_date: {
            map: 'function(doc) { emit([doc.type, doc.created_by, doc.created_date]); }'
          }
        }
      });
    }).then(function() {
      console.log('PouchDB initialised!');

      // TODO: this doesn't work more than once, probably because there are references held open to DBs
      return new Promise(function(resolve, reject) {
        // var closeDb = function(db) {
        //   return new Promise(resolve, reject) {
        //     if (!db) {
        //       resolve();
        //     }

        //     db.
        //   }
        // }

        if (iNative) iNative.close();
        var req = window.indexedDB.deleteDatabase(IDB_NATIVE_NAME);
        req.onerror = reject;
        req.onsuccess = function() {
          var native = window.indexedDB.open(IDB_NATIVE_NAME, 1);

          // TODO: work out the Chrome 30 version of this?
          native.onupgradeneeded = function(event) {
            var idb = event.target.result;
            idb.createObjectStore(iNativeData, { keyPath: '_id' });
            // I realise IRL these keyPaths would be not be named so nicely, and would be generated based on
            // what is emited from views.
            // NB: _id indexes aren't used in the bench, but are needed by pouch so when data
            //     changes you can find existing view entries and remove them
            var os1 = idb.createObjectStore(iViewCreatedDate, {autoIncrement: true});
            os1.createIndex('id', '_id');
            os1.createIndex(iViewCreatedDate, 'created_date', {unique: false});
            var os2 = idb.createObjectStore(iViewTypeByPersonByDate, {autoIncrement: true});
            os2.createIndex('id', '_id');
            os2.createIndex(iViewTypeByPersonByDate, ['type', 'created_by', 'created_date'], {unique: false});
          };

          native.onsuccess = function(event) {
            console.log('Native-Index IDB initialised!');
            iNative = native.result;
            resolve();
          };

          native.onerror = reject;
        };
      }).then(new Promise(function(resolve, reject) {
        // TODO: if open then close
        if (iArtificial) iArtificial.close();
        var req = window.indexedDB.deleteDatabase(IDB_ARTIFICIAL_NAME);
        req.onerror = reject;
        req.onsuccess = function() {
          var artificial = window.indexedDB.open(IDB_ARTIFICIAL_NAME, 1);

          artificial.onupgradeneeded = function(event) {
            var idb = event.target.result;
            idb.createObjectStore(iArtificialData, { keyPath: '_id' });

            var os1 = idb.createObjectStore(iArtificialView, {autoIncrement: true});
            os1.createIndex('id', '_id');
            os1.createIndex(iArtificialView, 'keyArray', {unique: false});
          };

          artificial.onsuccess = function(event) {
            console.log('Artificial-Index IDB initialised!');
            iArtificial = artificial.result;
            resolve();
          };

          artificial.onerror = reject;

        };
        }));
      });
  }

  // Nicked from: http://stackoverflow.com/questions/105034/ddg#2117523
  function uuidv4() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  function oneOf(things) {
    return things[Math.floor(Math.random() * things.length)];
  }

  function between(start, end) {
    return start + Math.random() * (end - start);
  }

  function aDate() {
    return Math.floor(between(Date.parse('2000'), Date.parse('2017')));
  };

  function generate() {
    var store = function(docs, total) {
      return time('insert-pouchdb', function() { return db.bulkDocs(docs); })
      .then(function() { return time('insert-native', function() {
        // Native
        var tx = iNative.transaction(iNative.objectStoreNames, "readwrite"); // TODO: maybe old style readwrite?

        var data = tx.objectStore(iNativeData),
            viewCreatedDate = tx.objectStore(iViewCreatedDate),
            viewTypeByPersonByDate = tx.objectStore(iViewTypeByPersonByDate);

        docs.forEach(doc => {
          data.add(doc);
          // Yes, this would be running the actual JS instead of manually rewriting it
          viewCreatedDate.add({
            created_date: doc.created_date,
            _id: doc._id
          });
          viewTypeByPersonByDate.add({
            type: doc.type,
            created_by: doc.created_by,
            created_date: doc.created_date,
            _id: doc._id
          });
        });

        return new Promise(function(resolve, reject) {
          tx.oncomplete = resolve;
          tx.onerror = reject;
        });
      });})
      .then(function() { return time('insert-artificial', function() {
        // Artificial
        var tx = iArtificial.transaction(iArtificial.objectStoreNames, "readwrite"); // TODO: maybe old style readwrite?

        var data = tx.objectStore(iArtificialData),
            views = tx.objectStore(iArtificialView);

        docs.forEach(doc => {
          data.add(doc);
          // Yes, this would be running the actual JS instead of manually rewriting it
          views.add({
            keyArray: [iViewCreatedDate, doc.created_date],
            _id: doc._id
          });
          views.add({
            // TODO: would keyArray[1] be an array or would it be exploded out?
            keyArray: [iViewTypeByPersonByDate, [doc.type, doc.created_by, doc.created_date]],
            _id: doc._id
          });
        });

        return new Promise(function(resolve, reject) {
          tx.oncomplete = resolve;
          tx.onerror = reject;
        });
      });})
      .then(function() {
        console.log('Generated', total);
      })
      .catch(function(err) {
        console.error('Failed to generate', total);
        console.error(err);
      });
    };

    var docsToGenerate = document.getElementById('documents').value;

    var BATCH_SIZE = 100;
    var docs = [];
    var total = 0;
    for (var i = 0; i < docsToGenerate; i++) {
      total += 1;
      docs.push({
        _id: uuidv4(),
        type: oneOf(['foo', 'bar', 'smang']),
        created_date: aDate(),
        created_by: 'person:' + Math.floor(between(0, 1000)),
        a_boolean: oneOf([true, false, null, undefined]),
      });

      if (docs.length === BATCH_SIZE) {
        store(docs, total);
        docs = [];
      }
    }
    store(docs, total)
      .then(function() {
        // TODO: pull info from idb as well?
        return db.info();
      })
      .then(function(info) {
        console.log('GENERATION COMPLETE');
        console.log('Total Docs:', info);
      })
      .catch(function(err) {
        console.error('Failed to info');
        console.error(err);
      });
  }

  document.getElementById('bootstrap').addEventListener('click', bootstrap);
  document.getElementById('generate').addEventListener('click', generate);
  var queryNative = function() {
    return new Promise(function(resolve, reject) {
      var tx = iNative.transaction(iNative.objectStoreNames);
      tx.objectStore(iViewCreatedDate)
        .index(iViewCreatedDate)
        .openCursor(window.IDBKeyRange.lowerBound(Date.parse('2010')))
        .onsuccess = function(event) {
          var cursor = event.target.result;
          console.debug(cursor.value);
          tx.objectStore(iViewTypeByPersonByDate)
            .index(iViewTypeByPersonByDate)
            .openCursor(window.IDBKeyRange.lowerBound(['foo']))
            .onsuccess = function(event) {
              var cursor = event.target.result;
              console.debug(cursor.value);
              resolve();
            };
        };
    });
  }

  var queryArtificial = function() {
    return new Promise(function(resolve, reject) {
      var tx = iArtificial.transaction(iArtificial.objectStoreNames);
      tx.objectStore(iArtificialView)
        .index(iArtificialView)
        .openCursor(window.IDBKeyRange.lowerBound([iViewCreatedDate, Date.parse('2010')]))
        .onsuccess = function(event) {
          var cursor = event.target.result;
          console.debug(cursor.value);
          tx.objectStore(iArtificialView)
            .index(iArtificialView)
            .openCursor(window.IDBKeyRange.lowerBound([iViewTypeByPersonByDate, ['foo']]))
            .onsuccess = function(event) {
              var cursor = event.target.result;
              console.debug(cursor.value);
              resolve();
            };
        };
    });
  };

  document.getElementById('indexes-pouchdb').addEventListener('click', function() {
    console.log('Warming PouchDB indexes...');

    time('warm-pouchdb', function() {return db.query('idbnext/created_date', {limit: 1});})
      .then(function(timed) {
        console.log('Warmed PouchDB indexes, took', timed[0], 'millis');
      });
  });

  document.getElementById('indexes-native').addEventListener('click', function() {
    console.log('Warming Native indexes');

    time('warm-native', queryNative).then(function(timed) {
      console.log('Warmed Native indexes, took', timed[0], 'millis');
    });
  });
  document.getElementById('indexes-artificial').addEventListener('click', function() {
    console.log('Warming Artificial indexes');

    time('warm-artificial', queryArtificial).then(function(timed) {
      console.log('Warmed Native indexes, took', timed[0], 'millis');
    });
  });
  document.getElementById('query-pouchdb').addEventListener('click', function() {
    time('query-pouchdb', function() {return db.query('idbnext/created_date', {limit: 1});})
      .then(function(timed) {
        console.log('Queried PouchDB indexes, took', timed[0], 'millis');
      });
  });
  document.getElementById('query-native').addEventListener('click', function() {
    time('query-native', queryNative).then(function(timed) {
      console.log('Warmed Native indexes, took', timed[0], 'millis');
    });
  });
  document.getElementById('query-artificial').addEventListener('click', function() {
    time('query-artificial', queryArtificial).then(function(timed) {
      console.log('Warmed Native indexes, took', timed[0], 'millis');
    });
  });
  document.getElementById('dump-timings').addEventListener('click', function() {
    console.log('TIMINGS');
    console.log(JSON.stringify(times, null, 2));
    console.log(times);
  });
  document.getElementById('reset-timings').addEventListener('click', function() {
    times = {};
    console.log('Reset times');
  });
</script>
</body>
</html>
